Slimeboi

Slimeboi is a 2D side-scrolling game developed using Python and Pygame. The game features a character that can move, jump, and interact with a parallax scrolling background. The character's color changes based on the layer it is in, and the game includes a simple point system that increases the score when the character is in the special layer.

Features

    Side Scrolling Movement: Move the character left, right, up, and down.
    Layer-Based Color Change: The character changes color based on the layer it is in.
    Score System: Points increase when the character is in a specific layer.
    Obstacle Interaction: Collide with obstacles to stop movement.
    Parallax Scrolling Background: Background layers move at different speeds for a parallax effect.

Setup

To run this game, you need to have Python and Pygame installed on your machine.

Requirements

    Python 3.x
    Pygame

Installation

git clone https://github.com/CyberiaPS1/slimeboi.git
Navigate to the Project Directory: cd slimeboi
Install Pygame:pip install pygame

Running the Game

To run the game, execute the main.py script using Python:
python main.py

Controls

    Arrow Keys: Move the character left, right, up, and down.
    Spacebar: (To be implemented for jumping if needed)

Game Mechanics

    Layer System: The game features two layers with different scrolling speeds. The character's color changes when it is in the second layer.
    Obstacles: Static obstacles are placed in the game world. The character cannot pass through these obstacles.

Customization

Feel free to modify the main.py file to adjust game mechanics, layer properties, or character behavior. You can also change the colors and sizes of various game elements.

Contribution

If you want to contribute to the development of Slimeboi, please open an issue or submit a pull request with your changes. Your contributions and feedback are welcome!

License

This project is licensed under the MIT License - see the LICENSE file for details.

Acknowledgments

    Pygame: For providing the framework to develop this game.

##FutureState

1. Core Engine Components
A. Rendering Engine

    2D Side Scrolling: Our engine needs to render a 2D world with parallax scrolling to create depth.
    Character Movement: The engine should support smooth character movement (left, right, jump) and animation blending.
    Environment Interaction: Implement a system to handle environmental interactions (e.g., doors, levers) and dynamic objects.
    Gadgets: The engine should allow characters to use gadgets with specific effects (e.g., EMPs, grappling hooks).

B. Physics Engine

    Basic 2D Physics: Implement collision detection for character movement and interactions with the environment.
    Stealth Mechanics: Physics should support hiding (e.g., crouching behind objects) and distractions (e.g., throwing items to create noise).

2. Stealth Mechanics
A. Detection System

    AI Vision Cones: The engine should handle enemy AI with vision cones to detect the player.
    Hiding Mechanics: Implement mechanics for the player to hide in specific areas (e.g., shadows, behind objects).
    Distraction: Allow the player to create distractions that affect the enemy’s detection abilities.

B. Rolling Dice System

    Chance-Based Outcome: When the player is detected, trigger a dice roll system that determines success or failure based on the player’s attributes.
    Attribute-Based Calculations: Incorporate player stats or attributes to influence the outcome of the dice roll.

3. Mini-Game System

    Mini-Game Trigger: When the player is caught, the engine should trigger a mini-game.
    Option Selection: The mini-game will present the player with options that, if chosen correctly, allow the player to return to a non-compromised state.
    Outcome Integration: Based on the mini-game’s result, update the game state (e.g., reset the stealth status or trigger an alert).

4. Platform Support

    Cross-Platform Compatibility: Ensure that the engine can export the game to various platforms (e.g., PC, consoles).
    Input Handling: The engine should support different input devices like keyboards, controllers, and potentially touchscreens.

5. Tools and Editors

    Level Editor: Develop or integrate a level editor that supports the design of 2D environments, placement of interactive objects, and enemy AI setup.
    Attribute and Dice System Editor: Create an editor for setting up and tweaking the character's attributes and the probability factors for the dice system.

6. Audio Engine

    Sound Effects: Manage sound effects for actions like jumping, using gadgets, or triggering stealth mechanics.
    Background Music: Support dynamic background music that changes based on the game state (e.g., tense music when detected).
    3D Positional Audio: If applicable, allow sounds to be positioned in 3D space to enhance immersion.

7. Optimization

    Performance: Optimize for smooth performance on various platforms, particularly for rendering and physics calculations.
    Memory Management: Ensure efficient memory use to handle large levels and multiple active objects.

8. Scripting and Modularity

    Lua/Python Integration: Integrate a scripting language like Lua or Python for defining gameplay logic, which will make it easier to tweak game mechanics without recompiling the engine.
    Modular Design: Build the engine in a modular way so that features like the stealth mechanics, mini-games, and dice system can be reused or modified without affecting other parts of the engine.
