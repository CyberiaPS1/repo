"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeOperation = void 0;
const error_1 = require("../error");
const read_preference_1 = require("../read_preference");
const server_selection_1 = require("../sdam/server_selection");
const utils_1 = require("../utils");
const operation_1 = require("./operation");
const MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;
const MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';

function executeOperation(client, operation, callback) {
    return (0, utils_1.maybeCallback)(() => executeOperationAsync(client, operation), callback);
}

exports.executeOperation = executeOperation;

async function executeOperationAsync(client, operation) {
    if (!(operation instanceof operation_1.AbstractOperation)) {
        // TODO(NODE-3483): Extend MongoRuntimeError
        throw new error_1.MongoRuntimeError('This method requires a valid operation instance');
    }

    if (client.topology == null) {
        // Auto connect on operation
        if (client.s.hasBeenClosed) {
            throw new error_1.MongoNotConnectedError('Client must be connected before running operations');
        }

        client.s.options[Symbol.for('@@mdb.skipPingOnConnect')] = true;

        try {
            await client.connect();
        }
        finally {
            delete client.s.options[Symbol.for('@@mdb.skipPingOnConnect')];
        }
    }

    const { topology } = client;

    if (topology == null) {
        throw new error_1.MongoRuntimeError('client.connect did not create a topology but also did not throw');
    }

    if (topology.shouldCheckForSessionSupport()) {
        await topology.selectServerAsync(read_preference_1.ReadPreference.primaryPreferred, {});
    }

    // The driver sessions spec mandates that we implicitly create sessions for operations
    // that are not explicitly provided with a session.
    let session = operation.session;
    let owner;

    if (topology.hasSessionSupport()) {
        if (session == null) {
            owner = Symbol();
            session = client.startSession({ owner, explicit: false });
        }
        else if (session.hasEnded) {
            throw new error_1.MongoExpiredSessionError('Use of expired sessions is not permitted');
        }
        else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {
            throw new error_1.MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later');
        }
    }
    else {
        // no session support
        if (session && session.explicit) {
            // If the user passed an explicit session and we are still, after server selection,
            // trying to run against a topology that doesn't support sessions we error out.
            throw new error_1.MongoCompatibilityError('Current topology does not support sessions');
        }
        else if (session && !session.explicit) {
            // We do not have to worry about ending the session because the server session has not been acquired yet
            delete operation.options.session;
            operation.clearSession();
            session = undefined;
        }
    }

    const readPreference = operation.readPreference && read_preference_1.ReadPreference.primary;
    const inTransaction = !!session && session.inTransaction();

    if
